package ca.jrvs.apps.trading.service;

import ca.jrvs.apps.trading.dao.AccountDao;
import ca.jrvs.apps.trading.dao.PositionDao;
import ca.jrvs.apps.trading.dao.SecurityOrderDao;
import ca.jrvs.apps.trading.dao.TraderDao;
import ca.jrvs.apps.trading.model.domain.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class TraderAccountService {

    private TraderDao traderDao;
    private AccountDao accountDao;
    private SecurityOrderDao securityOrderDao;
    private PositionDao positionDao;

    @Autowired
    public TraderAccountService(TraderDao traderDao, AccountDao accountDao,
                                SecurityOrderDao securityOrderDao, PositionDao positionDao) {
        this.accountDao = accountDao;
        this.positionDao = positionDao;
        this.securityOrderDao = securityOrderDao;
        this.traderDao = traderDao;

    }

    private void verifyTraderInput(Trader trader) {
        if (trader == null) {
            throw new IllegalArgumentException("Trader is not defined.");
        }
        if (trader.getCountry() == null) {
            throw new IllegalArgumentException("Trader's country is not defined.");
        }
        if (trader.getDob() == null) {
            throw new IllegalArgumentException("Trader's date of birth is not defined");
        }
        if (trader.getEmail() == null) {
            throw new IllegalArgumentException("Trader's email is not defined.");
        }
        if (trader.getFirstName() == null) {
            throw new IllegalArgumentException("Trader's first name is not defined");
        }
        if (trader.getLastName() == null) {
            throw new IllegalArgumentException("Trader's last name is not defined");
        }
        if (trader.getId() != null) {
            throw new IllegalArgumentException("Trader's Id must be null");
        }
    }

    /**
     * Create a new trader and initialize a new account with 0 amount
     *
     * @param trader not null. Only id can be null that is auto generated by db
     * @return traderAccountView
     * @throws IllegalArgumentException if any trader property is null except id
     */
    public TraderAccountView createTraderAndAccount(Trader trader) throws IllegalArgumentException {
        verifyTraderInput(trader);
        trader.setId(traderDao.save(trader).getId());
        Account account = new Account();
        account.setTraderId(trader.getId());
        account.setAmount(0d);
        account.setId(accountDao.save(account).getId());
        TraderAccountView traderAccountView = new TraderAccountView();
        traderAccountView.setAccountId(account.getId());
        traderAccountView.setBalance(0d);
        traderAccountView.setId(trader.getId());
        traderAccountView.setPosition(0);
        return traderAccountView;
    }

    /**
     * Delete trader, all securityOrders and account associated with this order
     * A trader can only be deleted if it has no open position and 0 cash balance
     */
    private void checkBalance(Account account) {
        if (account.getAmount() != 0) {
            throw new IllegalArgumentException("Unable to delete: Account balance is not 0");
        }
    }

    private void checkPosition(List<Position> positions) {
        for (Position position : positions) {
            if (position.getPosition() != 0) {
                throw new IllegalArgumentException("Unable to delete: Ticker position is not 0");
            }
        }
    }

    /**
     * @param traderId must not be null
     * @throws IllegalArgumentException if traderId is null or not found or unable to delete.
     */
    public void deleteTraderId(Integer traderId) throws IllegalArgumentException {
        Account account = accountDao.findRowByColumnId(traderId, "traderId").get(0);
        List<SecurityOrder> securityOrders = securityOrderDao.findRowByColumnId(account.getId(), "accountId");
        List<Position> positions = positionDao.findRowByColumnId(account.getId(), "accountId");
        checkBalance(account);
        if (positions.size() == 0) {
            checkPosition(positions);
        }
        if (securityOrders.size() != 0) {
            for (SecurityOrder securityOrder : securityOrders) {
                securityOrderDao.deleteById(securityOrder.getId());
            }
        }
        accountDao.deleteById(account.getId());
        traderDao.deleteById(traderId);
    }

    /**
     * Deposit and withdraw fund to an account by traderId
     * - validate traderId
     * - validate fund format. Fund must be greater than 0
     */
    private void validateTrader(Integer traderId) {
        Trader trader = traderDao.findById(traderId).get();
        if (trader == null) {
            throw new IllegalArgumentException("Trader - " + traderId + " not found or not available");
        }
    }

    private void validateFund(Double fund) {
        if (fund <= 0) {
            throw new IllegalArgumentException("Amount to be deposited or withdraw must be more than 0");
        }
    }

    /**
     * Deposit a fund to an account by traderId
     *
     * @param traderId must not be null
     * @param fund     must be greater than 0
     * @return updated Account
     * @throws IllegalArgumentException if traderId is null or not found and fund is less than or equal to 0.
     */
    public Account deposit(Integer traderId, Double fund) {
        validateTrader(traderId);
        validateFund(fund);
        Account account = accountDao.findRowByColumnId(traderId, "traderId").get(0);
        return accountDao.updateAccountAmount(account, fund);
    }

    /**
     * Withdraw a fund to an account by traderId
     *
     * @param traderId trader id
     * @param fund     amount cannot be 0 or less
     * @return updated account
     * @throws IllegalArgumentException if trader id is null or not found,
     *                                  fund is less than or equal to 0 then insufficient balance.
     */
    public Account withdraw(Integer traderId, Double fund) {
        validateTrader(traderId);
        validateFund(fund);
        Account account = accountDao.findRowByColumnId(traderId, "traderId").get(0);
        return accountDao.updateAccountAmount(account, fund * -1d);
    }

    public TraderDao getTraderDao() {
        return traderDao;
    }

    public void setTraderDao(TraderDao traderDao) {
        this.traderDao = traderDao;
    }

    public AccountDao getAccountDao() {
        return accountDao;
    }

    public void setAccountDao(AccountDao accountDao) {
        this.accountDao = accountDao;
    }

    public SecurityOrderDao getSecurityOrderDao() {
        return securityOrderDao;
    }

    public void setSecurityOrderDao(SecurityOrderDao securityOrderDao) {
        this.securityOrderDao = securityOrderDao;
    }

    public PositionDao getPositionDao() {
        return positionDao;
    }

    public void setPositionDao(PositionDao positionDao) {
        this.positionDao = positionDao;
    }


}
